一个测试文件
# 一：MySQL面试题[☺](https://www.notion.so/d765a96b55684f9b8036f9e9acfeb132?pvs=21)

### 一、mysql的逻辑架构分为哪几部分[♡](https://www.notion.so/d765a96b55684f9b8036f9e9acfeb132?pvs=21)

> 1.连接层处理客户端与服务器之间的连接 ，引入了线程池的概念，主要完成一些类似于连接处理、授权认证、及相关的安全方案。
> 

> 2.服务层完成核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行，最后生成相应的执行操作。
> 

> 3.引擎层存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。主要是MyISAM和InnoDB这两个引擎，MyISAM 注重性能，读取数据的速度非常的快，InnoDB注重事务，注重安全，读取速度比较慢。我们企业中，一般会做一个MySQL主从复制 可以将主的MySQL服务器，配置为InnoDB, 从服务器可以配置为MyISAM ，因为它负责读。这样可以做到读写分离。
> 

> 4.存储层主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。
> 

### 二、mysql的索引的数据类型是什么，为什么不使用红黑树、二叉树呢[☯](https://www.notion.so/d765a96b55684f9b8036f9e9acfeb132?pvs=21)

> mysql的索引的数据类型是： B+ Tree ，优点如下：数据存储有序，想查找某个范围速度非常的快，且数据节点和指针分开了，一次获取到的数据比之前多很多，这样的设计，如果同样是三层架构，可以存储的数据会更多, 更适合磁盘上的数据存储和查询。
> 

<aside>
💡 1、有序的，想查找某个范围速度非常的快

</aside>

<aside>
💡 2、数据节点和指针分开了，一次获取到的数据比之前多很多，这样的设计，同样是三层架构，可以存储的数据比较多。

</aside>

为什么不使用红黑树、二叉树原因如下：

> 1.平衡二叉树，因为可以自动的平衡，树的高度比之前小了很多，但是数据量上去以后，高度也会增加，查找到速度也会变慢。
> 

> 2.红黑树也是平衡二叉树的一种，只是比之前好了一点
> 

> 3.相对于红黑树和二叉树，B树索引具备更好的平衡性质，可以支持更大的数据量，并且可以在动态系统中高效的进行修改和更新。尽管B树索引的查询、插入和删除操作的性能略低于红黑树和二叉树，但是在实际应用中，由于B树索引的平衡性和可定制性等重要优势，使得B树索引在MySQL中得到了广泛的应用。
> 

### 三、mysql查询速度为何可以达到毫秒级？什么叫做缓冲池污染？[◁](https://www.notion.so/d765a96b55684f9b8036f9e9acfeb132?pvs=21)

Mysql 的底层是文件系统，查询数据是需要 IO 的，但是我们每次查询数据感觉没有那么慢，原因是数据库中有一层 Buffer Pool，缓冲池，简单来说就是一块内存区域。它存在的原因之一是为了避免每次都去访问磁盘，把最常访问的数据放在缓存里，提高数据的访问速度，同时也得益于得益于预读机制，磁盘读写的时候，是按照页的方式来读取的（例如一页数据为 16K），每次至少读入一页的数据，如果下次读取的数据就在页中，就不用再去磁盘上读取了，从而减少了磁盘 I/O，但是预读机制有可能会出现预读失效以及缓冲池污染的问题。（比如当执行一条 SQL 语句时，如果扫描了大量数据或是进行了全表扫描，此时缓冲池中就会加载大量的数据页，从而将缓冲池中已存在的所有页替换出去，这种情况是不合理，这就是缓冲池污染，并且还会导致MySQL 性能急剧下降。），解决此类问题的方法就是： 冷热数据分离（也就是将 LRU 链表分为两部分，一部分为热数据区域，一部分为冷数据区域。当数据页第一次被加载到缓冲池中的时候，先将其放到冷数据区域的链表头部，1s后该缓存页被访问了再将其移至热数据区域的链表头部）。

### 四、什么是事务，什么是事务的隔离级别？[◁](https://www.notion.so/d765a96b55684f9b8036f9e9acfeb132?pvs=21)

事务是指在数据库中执行的一系列操作，这些操作被视为单个逻辑单元，要么全部成功地执行，要么全部失败回滚。事务的目的是确保数据的一致性和完整性。

> 事务具有以下特性：
> 

> 原子性，一致性，隔离性，持久性。
> 

> 什么是事务的隔离级别：
> 

> 事务的隔离级别是指多个并发执行的事务之间相互隔离的程度。
> 

> 常见的事务隔离级别包括：
> 

> 读未提交（最低的隔离级别），读已提交，可重复读，串行化（最高的隔离级别）。
> 

### 五、如何分析一个sql的优劣？[◁](https://www.notion.so/d765a96b55684f9b8036f9e9acfeb132?pvs=21)

SQL的优劣主要取决于以下几个方面：

1. 查询语句的效率：即执行查询语句所需的时间和系统资源。可以通过分析SQL的执行计划，了解SQL语句的优化情况及其索引是否合理，以达到优化查询效率的目的。
2. 数据库表的设计：数据库表的设计不仅要考虑数据结构、数据类型等因素，而且需要合理的划分数据表以避免表过大，影响SQL的执行效率。
3. 索引的使用：索引是优化SQL执行效率的强有力工具，但过多的索引会占用系统资源，不利于效率的提高。
4. SQL语句的规范性：规范的SQL语句能够使查询的效率得到有效的提高，并避免一些无谓的查询和计算。
5. 防止SQL注入：对于动态构建SQL查询语句的操作，应该尽可能使用预编译语句或参数化查询，以防止SQL注入。

总之，SQL的优劣是一个综合性的问题，需要从多个方面进行分析和考虑。只有综合考虑以上因素，才能够充分发挥SQL的优势，提高系统的运行效率和性能。

### 六、sql优化方案。[◁](https://www.notion.so/d765a96b55684f9b8036f9e9acfeb132?pvs=21)

> sql优化呢，其实就是添加索引，添加索引就害怕索引失效，哪些写法可能出现索引失效呢？
> 

> 1、全字段匹配是最棒的比如一张表，将 name,age ,pos 组合成了一个联合索引，在where条件下，能够使用到的索引越多越好。
> 

> 2、最佳左前缀法则比如创建索引的时候， name --> age --> pos 在使用索引的时候，也必须按照这个顺序来，不能少，顺序可以乱。
> 

> 3、索引列上不计算不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。
> 

> 4、不能使用索引中范围条件右边的列
> 

> 5、尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *
> 

> 6、使用不等于(!= 或者<>)的时候无法使用索引，会让索引失效
> 

> 7、注意字段的null值和 not null 对sql的影响
> 

> 8、like以通配符开头('%abc...')mysql索引失效
> 

> 9、字符串不加单引号，底层使用数据类型转换索引失效
> 

> 10、少用or,用它来连接时会索引失效，可以用uniont替代口诀：
> 

全职匹配我最爱，最左前缀要遵守；

带头大哥不能死，中间兄弟不能断；

索引列上少计算，范围之后全失效；

LIKE百分写最右，覆盖索引无所谓；

不等空值还有OR，索引影响要注意；
